{"mappings":"AAAA,qBAAM,UAAU;;IAqHD,IAAI;CAKlB;AAED,eAAe,UAAU,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"class TextFields {\n  private textFieldContainer: (HTMLInputElement | HTMLTextAreaElement)[];\n  private floatingLabel: HTMLElement[];\n  private resizeObserver: ResizeObserver;\n  private notches: { container: HTMLElement; notch: HTMLElement }[] = [];\n\n  constructor() {\n    this.textFieldContainer = Array.from(document.querySelectorAll<HTMLInputElement | HTMLTextAreaElement>('.text-field-container input, .text-field-container textarea'));\n    this.floatingLabel = Array.from(document.querySelectorAll<HTMLElement>('.floating-label'));\n\n    this.resizeObserver = new ResizeObserver(entries => {\n      entries.forEach(entry => {\n        const notch = entry.target.closest('.notched-outline')?.querySelector<HTMLElement>('.notched-outline__notch');\n\n        if (notch) this.setNotchWidth(notch, this.getNotchWidth(notch));\n      });\n    });\n  }\n\n  private notched() {\n    this.floatingLabel.forEach(label => {\n      const notchedOutline = label.closest('.notched-outline') ?? this.createNotchedOutline(label);\n\n      this.notches.push({ container: notchedOutline.parentNode as HTMLElement, notch: notchedOutline.querySelector<HTMLElement>('.notched-outline__notch')! });\n\n      const lastNotch = this.notches.at(-1)!.notch;\n\n      this.setNotchWidth(lastNotch, this.getNotchWidth(lastNotch));\n      this.resizeObserver.observe(notchedOutline.querySelector<HTMLElement>('.floating-label')!);\n    });\n  }\n\n  private createNotchedOutline(label: HTMLElement): HTMLElement {\n    const notchedOutline = document.createElement('div');\n\n    notchedOutline.classList.add('notched-outline');\n    notchedOutline.innerHTML = `\n      <div class=\"notched-outline__leading\"></div>\n      <div class=\"notched-outline__notch\">${label.outerHTML}</div>\n      <div class=\"notched-outline__trailing\"></div>\n    `;\n    label.replaceWith(notchedOutline);\n\n    return notchedOutline;\n  }\n\n  private setNotchWidth = (notch: HTMLElement, width: string) => {\n    notch.style.width = width;\n  };\n\n  private getNotchWidth = (notch: HTMLElement): string => {\n    const label = notch.querySelector<HTMLElement>('.floating-label');\n    return label ? `${(parseFloat(getComputedStyle(label).width) + 13) * 0.75}px` : 'auto';\n  };\n\n  private handleEvents() {\n    this.textFieldContainer.forEach(field => {\n      const notchData = this.notches.find(data => data.container.contains(field));\n\n      if (!notchData) return;\n\n      this.setupObserver(field, notchData.container);\n      this.addListeners(field, notchData.container, notchData.notch, field instanceof HTMLTextAreaElement);\n    });\n  }\n\n  private initialNotchWidths() {\n    this.notches.forEach(({ notch }) => {\n      this.setNotchWidth(notch, this.getNotchWidth(notch));\n    });\n  }\n\n  private setupObserver(field: HTMLInputElement | HTMLTextAreaElement, container: HTMLElement) {\n    const fieldObserver = new MutationObserver(() => {\n      this.updateStyles(field, container, field instanceof HTMLTextAreaElement);\n    });\n\n    fieldObserver.observe(field, { attributes: true, attributeFilter: ['required', 'disabled'] });\n  }\n\n  private addListeners(field: HTMLInputElement | HTMLTextAreaElement, container: HTMLElement, notch: HTMLElement, fieldType: boolean) {\n    const eventType = fieldType ? 'input' : 'change';\n\n    field.addEventListener('focus', () => {\n      container.classList.add(fieldType ? 'textarea--focused' : 'input--focused');\n\n      this.setNotchWidth(notch, this.getNotchWidth(notch));\n    });\n\n    field.addEventListener('blur', () => {\n      container.classList.remove(fieldType ? 'textarea--focused' : 'input--focused');\n\n      this.setNotchWidth(notch, field.value.trim() ? this.getNotchWidth(notch) : 'auto');\n    });\n\n    field.addEventListener(eventType, () => {\n      this.updateStyles(field, container, fieldType);\n\n      if (fieldType) this.resizeTextarea(field as HTMLTextAreaElement, container);\n    });\n\n    this.updateStyles(field, container, fieldType);\n  }\n\n  private updateStyles(field: HTMLInputElement | HTMLTextAreaElement, container: HTMLElement, fieldType: boolean) {\n    container.classList.toggle(fieldType ? 'textarea--filled' : 'input--filled', field.value.trim().length > 0);\n    container.classList.toggle(fieldType ? 'textarea--disabled' : 'input--disabled', field.disabled);\n    container.classList.toggle(fieldType ? 'textarea--error' : 'input--error', field.required);\n  }\n\n  private resizeTextarea(field: HTMLTextAreaElement, container: HTMLElement) {\n    if (container.classList.contains('textarea--auto-resizeable')) {\n      field.style.height = 'auto';\n      field.style.height = `${field.scrollHeight}px`;\n    }\n  }\n\n  public async init() {\n    this.notched();\n    this.handleEvents();\n    this.initialNotchWidths();\n  }\n}\n\nexport default TextFields;\n"],"names":[],"version":3,"file":"index.d.ts.map"}