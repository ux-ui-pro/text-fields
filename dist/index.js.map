{"mappings":"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","sources":["src/index.ts"],"sourcesContent":["class TextFields {\n  private textFieldContainer: (HTMLInputElement | HTMLTextAreaElement)[];\n\n  private floatingLabel: HTMLElement[];\n\n  private resizeObserver: ResizeObserver;\n\n  private notches: { container: HTMLElement; notch: HTMLElement }[] = [];\n\n  private mutationObserver: MutationObserver;\n\n  constructor() {\n    this.textFieldContainer = [];\n    this.floatingLabel = [];\n    this.resizeObserver = new ResizeObserver(TextFields.handleResize.bind(this));\n    this.mutationObserver = new MutationObserver(this.initializeElements.bind(this));\n    this.observeDOMChanges();\n  }\n\n  private observeDOMChanges() {\n    this.mutationObserver.observe(document.body, { childList: true, subtree: true });\n  }\n\n  private static handleResize(entries: ResizeObserverEntry[]) {\n    entries.forEach((entry) => {\n      const notch = entry.target.closest('.notched-outline')?.querySelector<HTMLElement>('.notched-outline__notch');\n\n      if (notch) {\n        TextFields.setNotchWidth(notch, TextFields.getNotchWidth(notch));\n      }\n    });\n  }\n\n  private initializeElements() {\n    this.textFieldContainer = Array.from(document.querySelectorAll<HTMLInputElement | HTMLTextAreaElement>('.text-field-container input, .text-field-container textarea'));\n    this.floatingLabel = Array.from(document.querySelectorAll<HTMLElement>('.floating-label'));\n\n    if (this.textFieldContainer.length > 0 && this.floatingLabel.length > 0) {\n      this.setupNotches();\n      this.handleEvents();\n      this.updateInitialNotchWidths();\n    }\n  }\n\n  private setupNotches() {\n    this.floatingLabel.forEach((label) => {\n      const notchedOutline = label.closest('.notched-outline') ?? TextFields.createNotchedOutline(label);\n\n      if (notchedOutline) {\n        const notch = notchedOutline.querySelector<HTMLElement>('.notched-outline__notch');\n\n        if (notch) {\n          this.notches.push({ container: notchedOutline.parentElement as HTMLElement, notch });\n\n          TextFields.setNotchWidth(notch, TextFields.getNotchWidth(notch));\n\n          this.resizeObserver.observe(label);\n        }\n      }\n    });\n  }\n\n  private static createNotchedOutline(label: HTMLElement): HTMLElement {\n    const notchedOutline = document.createElement('div');\n\n    notchedOutline.classList.add('notched-outline');\n    notchedOutline.innerHTML = `\n      <div class=\"notched-outline__leading\"></div>\n      <div class=\"notched-outline__notch\">${label.outerHTML}</div>\n      <div class=\"notched-outline__trailing\"></div>\n    `;\n    label.replaceWith(notchedOutline);\n\n    return notchedOutline;\n  }\n\n  private static setNotchWidth(notch: HTMLElement, width: string) {\n    const newNotch = notch;\n\n    newNotch.style.width = width;\n  }\n\n  private static getNotchWidth(notch: HTMLElement): string {\n    const label = notch.querySelector<HTMLElement>('.floating-label');\n\n    return label ? `${(parseFloat(getComputedStyle(label).width) + 13) * 0.75}px` : 'auto';\n  }\n\n  private handleEvents() {\n    this.textFieldContainer.forEach((field) => {\n      const notchData = this.notches.find((data) => data.container.contains(field));\n\n      if (notchData) {\n        TextFields.setupFieldEvents(field, notchData.container, notchData.notch);\n      }\n    });\n  }\n\n  private updateInitialNotchWidths() {\n    this.notches.forEach(({ notch }) => {\n      TextFields.setNotchWidth(notch, TextFields.getNotchWidth(notch));\n    });\n  }\n\n  private static setupFieldEvents(field: HTMLInputElement | HTMLTextAreaElement, container: HTMLElement, notch: HTMLElement) {\n    const fieldType = field instanceof HTMLTextAreaElement;\n    const eventType = fieldType ? 'input' : 'change';\n\n    field.addEventListener('focus', () => {\n      container.classList.add(fieldType ? 'textarea--focused' : 'input--focused');\n      TextFields.setNotchWidth(notch, TextFields.getNotchWidth(notch));\n    });\n\n    field.addEventListener('blur', () => {\n      container.classList.remove(fieldType ? 'textarea--focused' : 'input--focused');\n      TextFields.setNotchWidth(notch, field.value.trim() ? TextFields.getNotchWidth(notch) : 'auto');\n    });\n\n    field.addEventListener(eventType, () => {\n      TextFields.updateStyles(field, container, fieldType);\n\n      if (fieldType) {\n        TextFields.resizeTextarea(field as HTMLTextAreaElement, container);\n      }\n    });\n\n    TextFields.updateStyles(field, container, fieldType);\n  }\n\n  private static updateStyles(field: HTMLInputElement | HTMLTextAreaElement, container: HTMLElement, fieldType: boolean) {\n    container.classList.toggle(fieldType ? 'textarea--filled' : 'input--filled', field.value.trim().length > 0);\n    container.classList.toggle(fieldType ? 'textarea--disabled' : 'input--disabled', field.disabled);\n  }\n\n  private static resizeTextarea(field: HTMLTextAreaElement, container: HTMLElement) {\n    if (container.classList.contains('textarea--auto-resizeable')) {\n      const newField = field;\n\n      newField.style.height = 'auto';\n      newField.style.height = `${field.scrollHeight}px`;\n    }\n  }\n\n  public async init() {\n    await new Promise<void>((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, 0);\n    });\n\n    this.initializeElements();\n  }\n}\n\nexport default TextFields;\n"],"names":[],"version":3,"file":"index.js.map"}